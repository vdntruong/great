// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: store.go.sql

package dao

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CreateStore = `-- name: CreateStore :one
INSERT INTO stores (
    id, name, slug, description, logo_url, cover_url,
    status, is_verified, owner_id, contact_email, contact_phone,
    address, settings
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13
) RETURNING id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at
`

type CreateStoreParams struct {
	ID           uuid.UUID             `db:"id" json:"id"`
	Name         string                `db:"name" json:"name"`
	Slug         string                `db:"slug" json:"slug"`
	Description  sql.NullString        `db:"description" json:"description"`
	LogoUrl      sql.NullString        `db:"logo_url" json:"logo_url"`
	CoverUrl     sql.NullString        `db:"cover_url" json:"cover_url"`
	Status       StoreStatus           `db:"status" json:"status"`
	IsVerified   bool                  `db:"is_verified" json:"is_verified"`
	OwnerID      uuid.UUID             `db:"owner_id" json:"owner_id"`
	ContactEmail sql.NullString        `db:"contact_email" json:"contact_email"`
	ContactPhone sql.NullString        `db:"contact_phone" json:"contact_phone"`
	Address      sql.NullString        `db:"address" json:"address"`
	Settings     pqtype.NullRawMessage `db:"settings" json:"settings"`
}

func (q *Queries) CreateStore(ctx context.Context, arg *CreateStoreParams) (*Store, error) {
	row := q.queryRow(ctx, q.createStoreStmt, CreateStore,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.LogoUrl,
		arg.CoverUrl,
		arg.Status,
		arg.IsVerified,
		arg.OwnerID,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.Address,
		arg.Settings,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const CreateStoreCategory = `-- name: CreateStoreCategory :one
INSERT INTO store_categories (
    id, store_id, name, slug, description,
    parent_id, sort_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, store_id, name, slug, description, parent_id, sort_order, created_at, updated_at
`

type CreateStoreCategoryParams struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	StoreID     uuid.UUID      `db:"store_id" json:"store_id"`
	Name        string         `db:"name" json:"name"`
	Slug        string         `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	ParentID    uuid.NullUUID  `db:"parent_id" json:"parent_id"`
	SortOrder   sql.NullInt32  `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateStoreCategory(ctx context.Context, arg *CreateStoreCategoryParams) (*StoreCategory, error) {
	row := q.queryRow(ctx, q.createStoreCategoryStmt, CreateStoreCategory,
		arg.ID,
		arg.StoreID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ParentID,
		arg.SortOrder,
	)
	var i StoreCategory
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteStore = `-- name: DeleteStore :exec
UPDATE stores SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteStoreStmt, DeleteStore, id)
	return err
}

const DeleteStoreCategory = `-- name: DeleteStoreCategory :exec
DELETE FROM store_categories WHERE id = $1
`

func (q *Queries) DeleteStoreCategory(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteStoreCategoryStmt, DeleteStoreCategory, id)
	return err
}

const GetStoreByID = `-- name: GetStoreByID :one
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStoreByID(ctx context.Context, id uuid.UUID) (*Store, error) {
	row := q.queryRow(ctx, q.getStoreByIDStmt, GetStoreByID, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetStoreBySlug = `-- name: GetStoreBySlug :one
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStoreBySlug(ctx context.Context, slug string) (*Store, error) {
	row := q.queryRow(ctx, q.getStoreBySlugStmt, GetStoreBySlug, slug)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetStoreCategories = `-- name: GetStoreCategories :many
SELECT id, store_id, name, slug, description, parent_id, sort_order, created_at, updated_at FROM store_categories WHERE store_id = $1 ORDER BY sort_order ASC
`

func (q *Queries) GetStoreCategories(ctx context.Context, storeID uuid.UUID) ([]*StoreCategory, error) {
	rows, err := q.query(ctx, q.getStoreCategoriesStmt, GetStoreCategories, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*StoreCategory{}
	for rows.Next() {
		var i StoreCategory
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetStoreCategoryByID = `-- name: GetStoreCategoryByID :one
SELECT id, store_id, name, slug, description, parent_id, sort_order, created_at, updated_at FROM store_categories WHERE id = $1
`

func (q *Queries) GetStoreCategoryByID(ctx context.Context, id uuid.UUID) (*StoreCategory, error) {
	row := q.queryRow(ctx, q.getStoreCategoryByIDStmt, GetStoreCategoryByID, id)
	var i StoreCategory
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetStoreCategoryBySlug = `-- name: GetStoreCategoryBySlug :one
SELECT id, store_id, name, slug, description, parent_id, sort_order, created_at, updated_at FROM store_categories WHERE store_id = $1 AND slug = $2
`

type GetStoreCategoryBySlugParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Slug    string    `db:"slug" json:"slug"`
}

func (q *Queries) GetStoreCategoryBySlug(ctx context.Context, arg *GetStoreCategoryBySlugParams) (*StoreCategory, error) {
	row := q.queryRow(ctx, q.getStoreCategoryBySlugStmt, GetStoreCategoryBySlug, arg.StoreID, arg.Slug)
	var i StoreCategory
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListStores = `-- name: ListStores :many
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListStoresParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListStores(ctx context.Context, arg *ListStoresParams) ([]*Store, error) {
	rows, err := q.query(ctx, q.listStoresStmt, ListStores, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.LogoUrl,
			&i.CoverUrl,
			&i.Status,
			&i.IsVerified,
			&i.OwnerID,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateStore = `-- name: UpdateStore :one
UPDATE stores SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    logo_url = COALESCE($5, logo_url),
    cover_url = COALESCE($6, cover_url),
    status = COALESCE($7, status),
    is_verified = COALESCE($8, is_verified),
    contact_email = COALESCE($9, contact_email),
    contact_phone = COALESCE($10, contact_phone),
    address = COALESCE($11, address),
    settings = COALESCE($12, settings),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at
`

type UpdateStoreParams struct {
	ID           uuid.UUID             `db:"id" json:"id"`
	Name         string                `db:"name" json:"name"`
	Slug         string                `db:"slug" json:"slug"`
	Description  sql.NullString        `db:"description" json:"description"`
	LogoUrl      sql.NullString        `db:"logo_url" json:"logo_url"`
	CoverUrl     sql.NullString        `db:"cover_url" json:"cover_url"`
	Status       StoreStatus           `db:"status" json:"status"`
	IsVerified   bool                  `db:"is_verified" json:"is_verified"`
	ContactEmail sql.NullString        `db:"contact_email" json:"contact_email"`
	ContactPhone sql.NullString        `db:"contact_phone" json:"contact_phone"`
	Address      sql.NullString        `db:"address" json:"address"`
	Settings     pqtype.NullRawMessage `db:"settings" json:"settings"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg *UpdateStoreParams) (*Store, error) {
	row := q.queryRow(ctx, q.updateStoreStmt, UpdateStore,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.LogoUrl,
		arg.CoverUrl,
		arg.Status,
		arg.IsVerified,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.Address,
		arg.Settings,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const UpdateStoreCategory = `-- name: UpdateStoreCategory :one
UPDATE store_categories SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    parent_id = COALESCE($5, parent_id),
    sort_order = COALESCE($6, sort_order),
    updated_at = NOW()
WHERE id = $1
RETURNING id, store_id, name, slug, description, parent_id, sort_order, created_at, updated_at
`

type UpdateStoreCategoryParams struct {
	ID          uuid.UUID      `db:"id" json:"id"`
	Name        string         `db:"name" json:"name"`
	Slug        string         `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	ParentID    uuid.NullUUID  `db:"parent_id" json:"parent_id"`
	SortOrder   sql.NullInt32  `db:"sort_order" json:"sort_order"`
}

func (q *Queries) UpdateStoreCategory(ctx context.Context, arg *UpdateStoreCategoryParams) (*StoreCategory, error) {
	row := q.queryRow(ctx, q.updateStoreCategoryStmt, UpdateStoreCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ParentID,
		arg.SortOrder,
	)
	var i StoreCategory
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
