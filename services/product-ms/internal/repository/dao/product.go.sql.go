// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.go.sql

package dao

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CreateProduct = `-- name: CreateProduct :one
INSERT INTO products (
    id, store_id, name, slug, description, type,
    status, price, compare_at_price, cost_price, sku, barcode,
    weight, weight_unit, is_taxable, is_featured, is_gift_card,
    requires_shipping, inventory_quantity, inventory_policy,
    inventory_tracking, seo_title, seo_description, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12,
    $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24
) RETURNING id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	ID                uuid.UUID             `db:"id" json:"id"`
	StoreID           uuid.UUID             `db:"store_id" json:"store_id"`
	Name              string                `db:"name" json:"name"`
	Slug              string                `db:"slug" json:"slug"`
	Description       sql.NullString        `db:"description" json:"description"`
	Type              ProductType           `db:"type" json:"type"`
	Status            ProductStatus         `db:"status" json:"status"`
	Price             string                `db:"price" json:"price"`
	CompareAtPrice    sql.NullString        `db:"compare_at_price" json:"compare_at_price"`
	CostPrice         sql.NullString        `db:"cost_price" json:"cost_price"`
	Sku               sql.NullString        `db:"sku" json:"sku"`
	Barcode           sql.NullString        `db:"barcode" json:"barcode"`
	Weight            sql.NullString        `db:"weight" json:"weight"`
	WeightUnit        sql.NullString        `db:"weight_unit" json:"weight_unit"`
	IsTaxable         sql.NullBool          `db:"is_taxable" json:"is_taxable"`
	IsFeatured        sql.NullBool          `db:"is_featured" json:"is_featured"`
	IsGiftCard        sql.NullBool          `db:"is_gift_card" json:"is_gift_card"`
	RequiresShipping  sql.NullBool          `db:"requires_shipping" json:"requires_shipping"`
	InventoryQuantity sql.NullInt32         `db:"inventory_quantity" json:"inventory_quantity"`
	InventoryPolicy   sql.NullString        `db:"inventory_policy" json:"inventory_policy"`
	InventoryTracking sql.NullBool          `db:"inventory_tracking" json:"inventory_tracking"`
	SeoTitle          sql.NullString        `db:"seo_title" json:"seo_title"`
	SeoDescription    sql.NullString        `db:"seo_description" json:"seo_description"`
	Metadata          pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg *CreateProductParams) (*Product, error) {
	row := q.queryRow(ctx, q.createProductStmt, CreateProduct,
		arg.ID,
		arg.StoreID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Price,
		arg.CompareAtPrice,
		arg.CostPrice,
		arg.Sku,
		arg.Barcode,
		arg.Weight,
		arg.WeightUnit,
		arg.IsTaxable,
		arg.IsFeatured,
		arg.IsGiftCard,
		arg.RequiresShipping,
		arg.InventoryQuantity,
		arg.InventoryPolicy,
		arg.InventoryTracking,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const CreateProductImage = `-- name: CreateProductImage :one
INSERT INTO product_images (
    id, product_id, variant_id, url, alt_text,
    type, sort_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, product_id, variant_id, url, alt_text, type, sort_order, created_at, updated_at
`

type CreateProductImageParams struct {
	ID        uuid.UUID      `db:"id" json:"id"`
	ProductID uuid.UUID      `db:"product_id" json:"product_id"`
	VariantID uuid.NullUUID  `db:"variant_id" json:"variant_id"`
	Url       string         `db:"url" json:"url"`
	AltText   sql.NullString `db:"alt_text" json:"alt_text"`
	Type      ImageType      `db:"type" json:"type"`
	SortOrder sql.NullInt32  `db:"sort_order" json:"sort_order"`
}

func (q *Queries) CreateProductImage(ctx context.Context, arg *CreateProductImageParams) (*ProductImage, error) {
	row := q.queryRow(ctx, q.createProductImageStmt, CreateProductImage,
		arg.ID,
		arg.ProductID,
		arg.VariantID,
		arg.Url,
		arg.AltText,
		arg.Type,
		arg.SortOrder,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.VariantID,
		&i.Url,
		&i.AltText,
		&i.Type,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CreateProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (
    id, product_id, name, sku, price, compare_at_price,
    weight, weight_unit, inventory_quantity, option_values
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, product_id, name, sku, barcode, price, compare_at_price, cost_price, weight, weight_unit, inventory_quantity, inventory_policy, inventory_tracking, option_values, created_at, updated_at
`

type CreateProductVariantParams struct {
	ID                uuid.UUID       `db:"id" json:"id"`
	ProductID         uuid.UUID       `db:"product_id" json:"product_id"`
	Name              string          `db:"name" json:"name"`
	Sku               sql.NullString  `db:"sku" json:"sku"`
	Price             string          `db:"price" json:"price"`
	CompareAtPrice    sql.NullString  `db:"compare_at_price" json:"compare_at_price"`
	Weight            sql.NullString  `db:"weight" json:"weight"`
	WeightUnit        sql.NullString  `db:"weight_unit" json:"weight_unit"`
	InventoryQuantity sql.NullInt32   `db:"inventory_quantity" json:"inventory_quantity"`
	OptionValues      json.RawMessage `db:"option_values" json:"option_values"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg *CreateProductVariantParams) (*ProductVariant, error) {
	row := q.queryRow(ctx, q.createProductVariantStmt, CreateProductVariant,
		arg.ID,
		arg.ProductID,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.CompareAtPrice,
		arg.Weight,
		arg.WeightUnit,
		arg.InventoryQuantity,
		arg.OptionValues,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Weight,
		&i.WeightUnit,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.OptionValues,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteProduct = `-- name: DeleteProduct :exec
UPDATE products SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteProductStmt, DeleteProduct, id)
	return err
}

const DeleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM product_images WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteProductImageStmt, DeleteProductImage, id)
	return err
}

const DeleteProductVariant = `-- name: DeleteProductVariant :exec
DELETE FROM product_variants WHERE id = $1
`

func (q *Queries) DeleteProductVariant(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteProductVariantStmt, DeleteProductVariant, id)
	return err
}

const GetProductByID = `-- name: GetProductByID :one
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (*Product, error) {
	row := q.queryRow(ctx, q.getProductByIDStmt, GetProductByID, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetProductBySlug = `-- name: GetProductBySlug :one
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products WHERE store_id = $1 AND slug = $2 AND deleted_at IS NULL
`

type GetProductBySlugParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Slug    string    `db:"slug" json:"slug"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, arg *GetProductBySlugParams) (*Product, error) {
	row := q.queryRow(ctx, q.getProductBySlugStmt, GetProductBySlug, arg.StoreID, arg.Slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetProductImageByID = `-- name: GetProductImageByID :one
SELECT id, product_id, variant_id, url, alt_text, type, sort_order, created_at, updated_at FROM product_images WHERE id = $1
`

func (q *Queries) GetProductImageByID(ctx context.Context, id uuid.UUID) (*ProductImage, error) {
	row := q.queryRow(ctx, q.getProductImageByIDStmt, GetProductImageByID, id)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.VariantID,
		&i.Url,
		&i.AltText,
		&i.Type,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetProductImages = `-- name: GetProductImages :many
SELECT id, product_id, variant_id, url, alt_text, type, sort_order, created_at, updated_at FROM product_images WHERE product_id = $1 ORDER BY sort_order ASC
`

func (q *Queries) GetProductImages(ctx context.Context, productID uuid.UUID) ([]*ProductImage, error) {
	rows, err := q.query(ctx, q.getProductImagesStmt, GetProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.VariantID,
			&i.Url,
			&i.AltText,
			&i.Type,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductVariantByID = `-- name: GetProductVariantByID :one
SELECT id, product_id, name, sku, barcode, price, compare_at_price, cost_price, weight, weight_unit, inventory_quantity, inventory_policy, inventory_tracking, option_values, created_at, updated_at FROM product_variants WHERE id = $1
`

func (q *Queries) GetProductVariantByID(ctx context.Context, id uuid.UUID) (*ProductVariant, error) {
	row := q.queryRow(ctx, q.getProductVariantByIDStmt, GetProductVariantByID, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Weight,
		&i.WeightUnit,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.OptionValues,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetProductVariants = `-- name: GetProductVariants :many
SELECT id, product_id, name, sku, barcode, price, compare_at_price, cost_price, weight, weight_unit, inventory_quantity, inventory_policy, inventory_tracking, option_values, created_at, updated_at FROM product_variants WHERE product_id = $1 ORDER BY created_at ASC
`

func (q *Queries) GetProductVariants(ctx context.Context, productID uuid.UUID) ([]*ProductVariant, error) {
	rows, err := q.query(ctx, q.getProductVariantsStmt, GetProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Sku,
			&i.Barcode,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Weight,
			&i.WeightUnit,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.OptionValues,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProducts = `-- name: ListProducts :many
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products WHERE store_id = $1 AND deleted_at IS NULL ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListProductsParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg *ListProductsParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.listProductsStmt, ListProducts, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProductsByCategory = `-- name: ListProductsByCategory :many
SELECT p.id, p.store_id, p.name, p.slug, p.description, p.type, p.status, p.price, p.compare_at_price, p.cost_price, p.sku, p.barcode, p.weight, p.weight_unit, p.is_taxable, p.is_featured, p.is_gift_card, p.requires_shipping, p.inventory_quantity, p.inventory_policy, p.inventory_tracking, p.seo_title, p.seo_description, p.metadata, p.created_at, p.updated_at, p.deleted_at FROM products p
JOIN product_categories pc ON p.id = pc.product_id
WHERE pc.category_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg *ListProductsByCategoryParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.listProductsByCategoryStmt, ListProductsByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProduct = `-- name: UpdateProduct :one
UPDATE products SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    type = COALESCE($5, type),
    status = COALESCE($6, status),
    price = COALESCE($7, price),
    compare_at_price = COALESCE($8, compare_at_price),
    cost_price = COALESCE($9, cost_price),
    sku = COALESCE($10, sku),
    barcode = COALESCE($11, barcode),
    weight = COALESCE($12, weight),
    weight_unit = COALESCE($13, weight_unit),
    is_taxable = COALESCE($14, is_taxable),
    is_featured = COALESCE($15, is_featured),
    is_gift_card = COALESCE($16, is_gift_card),
    requires_shipping = COALESCE($17, requires_shipping),
    inventory_quantity = COALESCE($18, inventory_quantity),
    inventory_policy = COALESCE($19, inventory_policy),
    inventory_tracking = COALESCE($20, inventory_tracking),
    seo_title = COALESCE($21, seo_title),
    seo_description = COALESCE($22, seo_description),
    metadata = COALESCE($23, metadata),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID                uuid.UUID             `db:"id" json:"id"`
	Name              string                `db:"name" json:"name"`
	Slug              string                `db:"slug" json:"slug"`
	Description       sql.NullString        `db:"description" json:"description"`
	Type              ProductType           `db:"type" json:"type"`
	Status            ProductStatus         `db:"status" json:"status"`
	Price             string                `db:"price" json:"price"`
	CompareAtPrice    sql.NullString        `db:"compare_at_price" json:"compare_at_price"`
	CostPrice         sql.NullString        `db:"cost_price" json:"cost_price"`
	Sku               sql.NullString        `db:"sku" json:"sku"`
	Barcode           sql.NullString        `db:"barcode" json:"barcode"`
	Weight            sql.NullString        `db:"weight" json:"weight"`
	WeightUnit        sql.NullString        `db:"weight_unit" json:"weight_unit"`
	IsTaxable         sql.NullBool          `db:"is_taxable" json:"is_taxable"`
	IsFeatured        sql.NullBool          `db:"is_featured" json:"is_featured"`
	IsGiftCard        sql.NullBool          `db:"is_gift_card" json:"is_gift_card"`
	RequiresShipping  sql.NullBool          `db:"requires_shipping" json:"requires_shipping"`
	InventoryQuantity sql.NullInt32         `db:"inventory_quantity" json:"inventory_quantity"`
	InventoryPolicy   sql.NullString        `db:"inventory_policy" json:"inventory_policy"`
	InventoryTracking sql.NullBool          `db:"inventory_tracking" json:"inventory_tracking"`
	SeoTitle          sql.NullString        `db:"seo_title" json:"seo_title"`
	SeoDescription    sql.NullString        `db:"seo_description" json:"seo_description"`
	Metadata          pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg *UpdateProductParams) (*Product, error) {
	row := q.queryRow(ctx, q.updateProductStmt, UpdateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Price,
		arg.CompareAtPrice,
		arg.CostPrice,
		arg.Sku,
		arg.Barcode,
		arg.Weight,
		arg.WeightUnit,
		arg.IsTaxable,
		arg.IsFeatured,
		arg.IsGiftCard,
		arg.RequiresShipping,
		arg.InventoryQuantity,
		arg.InventoryPolicy,
		arg.InventoryTracking,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const UpdateProductImage = `-- name: UpdateProductImage :one
UPDATE product_images SET
    url = COALESCE($2, url),
    alt_text = COALESCE($3, alt_text),
    type = COALESCE($4, type),
    sort_order = COALESCE($5, sort_order),
    updated_at = NOW()
WHERE id = $1
RETURNING id, product_id, variant_id, url, alt_text, type, sort_order, created_at, updated_at
`

type UpdateProductImageParams struct {
	ID        uuid.UUID      `db:"id" json:"id"`
	Url       string         `db:"url" json:"url"`
	AltText   sql.NullString `db:"alt_text" json:"alt_text"`
	Type      ImageType      `db:"type" json:"type"`
	SortOrder sql.NullInt32  `db:"sort_order" json:"sort_order"`
}

func (q *Queries) UpdateProductImage(ctx context.Context, arg *UpdateProductImageParams) (*ProductImage, error) {
	row := q.queryRow(ctx, q.updateProductImageStmt, UpdateProductImage,
		arg.ID,
		arg.Url,
		arg.AltText,
		arg.Type,
		arg.SortOrder,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.VariantID,
		&i.Url,
		&i.AltText,
		&i.Type,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variants SET
    name = COALESCE($2, name),
    sku = COALESCE($3, sku),
    price = COALESCE($4, price),
    compare_at_price = COALESCE($5, compare_at_price),
    weight = COALESCE($6, weight),
    weight_unit = COALESCE($7, weight_unit),
    inventory_quantity = COALESCE($8, inventory_quantity),
    option_values = COALESCE($9, option_values),
    updated_at = NOW()
WHERE id = $1
RETURNING id, product_id, name, sku, barcode, price, compare_at_price, cost_price, weight, weight_unit, inventory_quantity, inventory_policy, inventory_tracking, option_values, created_at, updated_at
`

type UpdateProductVariantParams struct {
	ID                uuid.UUID       `db:"id" json:"id"`
	Name              string          `db:"name" json:"name"`
	Sku               sql.NullString  `db:"sku" json:"sku"`
	Price             string          `db:"price" json:"price"`
	CompareAtPrice    sql.NullString  `db:"compare_at_price" json:"compare_at_price"`
	Weight            sql.NullString  `db:"weight" json:"weight"`
	WeightUnit        sql.NullString  `db:"weight_unit" json:"weight_unit"`
	InventoryQuantity sql.NullInt32   `db:"inventory_quantity" json:"inventory_quantity"`
	OptionValues      json.RawMessage `db:"option_values" json:"option_values"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg *UpdateProductVariantParams) (*ProductVariant, error) {
	row := q.queryRow(ctx, q.updateProductVariantStmt, UpdateProductVariant,
		arg.ID,
		arg.Name,
		arg.Sku,
		arg.Price,
		arg.CompareAtPrice,
		arg.Weight,
		arg.WeightUnit,
		arg.InventoryQuantity,
		arg.OptionValues,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.Barcode,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Weight,
		&i.WeightUnit,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.OptionValues,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
