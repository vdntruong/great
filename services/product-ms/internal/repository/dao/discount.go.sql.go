// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: discount.go.sql

package dao

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const AddDiscountCategory = `-- name: AddDiscountCategory :exec
INSERT INTO discount_categories (discount_id, category_id) VALUES ($1, $2)
`

type AddDiscountCategoryParams struct {
	DiscountID uuid.UUID `db:"discount_id" json:"discount_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) AddDiscountCategory(ctx context.Context, arg *AddDiscountCategoryParams) error {
	_, err := q.exec(ctx, q.addDiscountCategoryStmt, AddDiscountCategory, arg.DiscountID, arg.CategoryID)
	return err
}

const AddDiscountProduct = `-- name: AddDiscountProduct :exec
INSERT INTO discount_products (discount_id, product_id) VALUES ($1, $2)
`

type AddDiscountProductParams struct {
	DiscountID uuid.UUID `db:"discount_id" json:"discount_id"`
	ProductID  uuid.UUID `db:"product_id" json:"product_id"`
}

func (q *Queries) AddDiscountProduct(ctx context.Context, arg *AddDiscountProductParams) error {
	_, err := q.exec(ctx, q.addDiscountProductStmt, AddDiscountProduct, arg.DiscountID, arg.ProductID)
	return err
}

const CountDiscounts = `-- name: CountDiscounts :one
SELECT COUNT(*) FROM discounts WHERE store_id = $1
`

func (q *Queries) CountDiscounts(ctx context.Context, storeID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countDiscountsStmt, CountDiscounts, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateDiscount = `-- name: CreateDiscount :one
INSERT INTO discounts (
    id, store_id, name, code, type, value,
    scope, start_date, end_date, min_purchase_amount,
    max_discount_amount, usage_limit, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13
) RETURNING id, store_id, name, code, type, value, scope, start_date, end_date, min_purchase_amount, max_discount_amount, usage_limit, usage_count, is_active, created_at, updated_at
`

type CreateDiscountParams struct {
	ID                uuid.UUID      `db:"id" json:"id"`
	StoreID           uuid.UUID      `db:"store_id" json:"store_id"`
	Name              string         `db:"name" json:"name"`
	Code              string         `db:"code" json:"code"`
	Type              DiscountType   `db:"type" json:"type"`
	Value             string         `db:"value" json:"value"`
	Scope             DiscountScope  `db:"scope" json:"scope"`
	StartDate         time.Time      `db:"start_date" json:"start_date"`
	EndDate           sql.NullTime   `db:"end_date" json:"end_date"`
	MinPurchaseAmount sql.NullString `db:"min_purchase_amount" json:"min_purchase_amount"`
	MaxDiscountAmount sql.NullString `db:"max_discount_amount" json:"max_discount_amount"`
	UsageLimit        sql.NullInt32  `db:"usage_limit" json:"usage_limit"`
	IsActive          sql.NullBool   `db:"is_active" json:"is_active"`
}

func (q *Queries) CreateDiscount(ctx context.Context, arg *CreateDiscountParams) (*Discount, error) {
	row := q.queryRow(ctx, q.createDiscountStmt, CreateDiscount,
		arg.ID,
		arg.StoreID,
		arg.Name,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.Scope,
		arg.StartDate,
		arg.EndDate,
		arg.MinPurchaseAmount,
		arg.MaxDiscountAmount,
		arg.UsageLimit,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.StartDate,
		&i.EndDate,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteDiscount = `-- name: DeleteDiscount :exec
DELETE FROM discounts WHERE id = $1
`

func (q *Queries) DeleteDiscount(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteDiscountStmt, DeleteDiscount, id)
	return err
}

const GetDiscountByCode = `-- name: GetDiscountByCode :one
SELECT id, store_id, name, code, type, value, scope, start_date, end_date, min_purchase_amount, max_discount_amount, usage_limit, usage_count, is_active, created_at, updated_at FROM discounts WHERE store_id = $1 AND code = $2
`

type GetDiscountByCodeParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Code    string    `db:"code" json:"code"`
}

func (q *Queries) GetDiscountByCode(ctx context.Context, arg *GetDiscountByCodeParams) (*Discount, error) {
	row := q.queryRow(ctx, q.getDiscountByCodeStmt, GetDiscountByCode, arg.StoreID, arg.Code)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.StartDate,
		&i.EndDate,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetDiscountByID = `-- name: GetDiscountByID :one
SELECT id, store_id, name, code, type, value, scope, start_date, end_date, min_purchase_amount, max_discount_amount, usage_limit, usage_count, is_active, created_at, updated_at FROM discounts WHERE id = $1
`

func (q *Queries) GetDiscountByID(ctx context.Context, id uuid.UUID) (*Discount, error) {
	row := q.queryRow(ctx, q.getDiscountByIDStmt, GetDiscountByID, id)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.StartDate,
		&i.EndDate,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetDiscountCategories = `-- name: GetDiscountCategories :many
SELECT c.id, c.store_id, c.name, c.slug, c.description, c.parent_id, c.sort_order, c.created_at, c.updated_at FROM store_categories c
JOIN discount_categories dc ON c.id = dc.category_id
WHERE dc.discount_id = $1
`

func (q *Queries) GetDiscountCategories(ctx context.Context, discountID uuid.UUID) ([]*StoreCategory, error) {
	rows, err := q.query(ctx, q.getDiscountCategoriesStmt, GetDiscountCategories, discountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*StoreCategory{}
	for rows.Next() {
		var i StoreCategory
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetDiscountProducts = `-- name: GetDiscountProducts :many
SELECT p.id, p.store_id, p.name, p.slug, p.description, p.type, p.status, p.price, p.compare_at_price, p.cost_price, p.sku, p.barcode, p.weight, p.weight_unit, p.is_taxable, p.is_featured, p.is_gift_card, p.requires_shipping, p.inventory_quantity, p.inventory_policy, p.inventory_tracking, p.seo_title, p.seo_description, p.metadata, p.created_at, p.updated_at, p.deleted_at FROM products p
JOIN discount_products dp ON p.id = dp.product_id
WHERE dp.discount_id = $1
`

func (q *Queries) GetDiscountProducts(ctx context.Context, discountID uuid.UUID) ([]*Product, error) {
	rows, err := q.query(ctx, q.getDiscountProductsStmt, GetDiscountProducts, discountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDiscounts = `-- name: ListDiscounts :many
SELECT id, store_id, name, code, type, value, scope, start_date, end_date, min_purchase_amount, max_discount_amount, usage_limit, usage_count, is_active, created_at, updated_at FROM discounts WHERE store_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3
`

type ListDiscountsParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListDiscounts(ctx context.Context, arg *ListDiscountsParams) ([]*Discount, error) {
	rows, err := q.query(ctx, q.listDiscountsStmt, ListDiscounts, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Discount{}
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Code,
			&i.Type,
			&i.Value,
			&i.Scope,
			&i.StartDate,
			&i.EndDate,
			&i.MinPurchaseAmount,
			&i.MaxDiscountAmount,
			&i.UsageLimit,
			&i.UsageCount,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveDiscountCategory = `-- name: RemoveDiscountCategory :exec
DELETE FROM discount_categories WHERE discount_id = $1 AND category_id = $2
`

type RemoveDiscountCategoryParams struct {
	DiscountID uuid.UUID `db:"discount_id" json:"discount_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) RemoveDiscountCategory(ctx context.Context, arg *RemoveDiscountCategoryParams) error {
	_, err := q.exec(ctx, q.removeDiscountCategoryStmt, RemoveDiscountCategory, arg.DiscountID, arg.CategoryID)
	return err
}

const RemoveDiscountProduct = `-- name: RemoveDiscountProduct :exec
DELETE FROM discount_products WHERE discount_id = $1 AND product_id = $2
`

type RemoveDiscountProductParams struct {
	DiscountID uuid.UUID `db:"discount_id" json:"discount_id"`
	ProductID  uuid.UUID `db:"product_id" json:"product_id"`
}

func (q *Queries) RemoveDiscountProduct(ctx context.Context, arg *RemoveDiscountProductParams) error {
	_, err := q.exec(ctx, q.removeDiscountProductStmt, RemoveDiscountProduct, arg.DiscountID, arg.ProductID)
	return err
}

const UpdateDiscount = `-- name: UpdateDiscount :one
UPDATE discounts SET
    name = COALESCE(NULLIF($2, ''), name),
    code = COALESCE(NULLIF($3, ''), code),
    type = COALESCE(NULLIF($4, '')::discount_type, type),
    value = COALESCE(NULLIF($5, ''), value),
    scope = COALESCE(NULLIF($6, '')::discount_scope, scope),
    start_date = COALESCE($7, start_date),
    end_date = COALESCE($8, end_date),
    min_purchase_amount = COALESCE(NULLIF($9, ''), min_purchase_amount),
    max_discount_amount = COALESCE(NULLIF($10, ''), max_discount_amount),
    usage_limit = COALESCE($11, usage_limit),
    is_active = COALESCE($12, is_active),
    updated_at = NOW()
WHERE id = $1
RETURNING id, store_id, name, code, type, value, scope, start_date, end_date, min_purchase_amount, max_discount_amount, usage_limit, usage_count, is_active, created_at, updated_at
`

type UpdateDiscountParams struct {
	ID         uuid.UUID     `db:"id" json:"id"`
	Column2    interface{}   `db:"column_2" json:"column_2"`
	Column3    interface{}   `db:"column_3" json:"column_3"`
	Column4    interface{}   `db:"column_4" json:"column_4"`
	Column5    interface{}   `db:"column_5" json:"column_5"`
	Column6    interface{}   `db:"column_6" json:"column_6"`
	StartDate  time.Time     `db:"start_date" json:"start_date"`
	EndDate    sql.NullTime  `db:"end_date" json:"end_date"`
	Column9    interface{}   `db:"column_9" json:"column_9"`
	Column10   interface{}   `db:"column_10" json:"column_10"`
	UsageLimit sql.NullInt32 `db:"usage_limit" json:"usage_limit"`
	IsActive   sql.NullBool  `db:"is_active" json:"is_active"`
}

func (q *Queries) UpdateDiscount(ctx context.Context, arg *UpdateDiscountParams) (*Discount, error) {
	row := q.queryRow(ctx, q.updateDiscountStmt, UpdateDiscount,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.StartDate,
		arg.EndDate,
		arg.Column9,
		arg.Column10,
		arg.UsageLimit,
		arg.IsActive,
	)
	var i Discount
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.Scope,
		&i.StartDate,
		&i.EndDate,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
