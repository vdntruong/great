// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product.sql

package dao

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CountProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE store_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProducts(ctx context.Context, storeID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countProductsStmt, CountProducts, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountProductsByStatus = `-- name: CountProductsByStatus :one
SELECT COUNT(*) FROM products
WHERE store_id = $1 AND status = $2 AND deleted_at IS NULL
`

type CountProductsByStatusParams struct {
	StoreID uuid.UUID     `db:"store_id" json:"store_id"`
	Status  ProductStatus `db:"status" json:"status"`
}

func (q *Queries) CountProductsByStatus(ctx context.Context, arg *CountProductsByStatusParams) (int64, error) {
	row := q.queryRow(ctx, q.countProductsByStatusStmt, CountProductsByStatus, arg.StoreID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateProduct = `-- name: CreateProduct :one
INSERT INTO products (
    store_id,
    name,
    slug,
    description,
    type,
    status,
    price,
    compare_at_price,
    cost_price,
    sku,
    barcode,
    weight,
    weight_unit,
    is_taxable,
    is_featured,
    is_gift_card,
    requires_shipping,
    inventory_quantity,
    inventory_policy,
    inventory_tracking,
    seo_title,
    seo_description,
    metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
) RETURNING id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	StoreID           uuid.UUID             `db:"store_id" json:"store_id"`
	Name              string                `db:"name" json:"name"`
	Slug              string                `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	Type        ProductType    `db:"type" json:"type"`
	Status      ProductStatus  `db:"status" json:"status"`
	Price       string         `db:"price" json:"price"`
	CompareAtPrice    sql.NullString        `db:"compare_at_price" json:"compare_at_price"`
	CostPrice         sql.NullString        `db:"cost_price" json:"cost_price"`
	Sku               sql.NullString        `db:"sku" json:"sku"`
	Barcode           sql.NullString        `db:"barcode" json:"barcode"`
	Weight            sql.NullString        `db:"weight" json:"weight"`
	WeightUnit        sql.NullString        `db:"weight_unit" json:"weight_unit"`
	IsTaxable         sql.NullBool          `db:"is_taxable" json:"is_taxable"`
	IsFeatured        sql.NullBool          `db:"is_featured" json:"is_featured"`
	IsGiftCard        sql.NullBool          `db:"is_gift_card" json:"is_gift_card"`
	RequiresShipping  sql.NullBool          `db:"requires_shipping" json:"requires_shipping"`
	InventoryQuantity sql.NullInt32         `db:"inventory_quantity" json:"inventory_quantity"`
	InventoryPolicy   sql.NullString        `db:"inventory_policy" json:"inventory_policy"`
	InventoryTracking sql.NullBool          `db:"inventory_tracking" json:"inventory_tracking"`
	SeoTitle          sql.NullString        `db:"seo_title" json:"seo_title"`
	SeoDescription    sql.NullString        `db:"seo_description" json:"seo_description"`
	Metadata          pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg *CreateProductParams) (*Product, error) {
	row := q.queryRow(ctx, q.createProductStmt, CreateProduct,
		arg.StoreID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Price,
		arg.CompareAtPrice,
		arg.CostPrice,
		arg.Sku,
		arg.Barcode,
		arg.Weight,
		arg.WeightUnit,
		arg.IsTaxable,
		arg.IsFeatured,
		arg.IsGiftCard,
		arg.RequiresShipping,
		arg.InventoryQuantity,
		arg.InventoryPolicy,
		arg.InventoryTracking,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const DeleteProduct = `-- name: DeleteProduct :exec
UPDATE products
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteProductStmt, DeleteProduct, id)
	return err
}

const GetProduct = `-- name: GetProduct :one
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (*Product, error) {
	row := q.queryRow(ctx, q.getProductStmt, GetProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetProductBySlug = `-- name: GetProductBySlug :one
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products
WHERE store_id = $1 AND slug = $2 AND deleted_at IS NULL
`

type GetProductBySlugParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Slug    string    `db:"slug" json:"slug"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, arg *GetProductBySlugParams) (*Product, error) {
	row := q.queryRow(ctx, q.getProductBySlugStmt, GetProductBySlug, arg.StoreID, arg.Slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const ListFeaturedProducts = `-- name: ListFeaturedProducts :many
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products
WHERE store_id = $1 AND is_featured = true AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListFeaturedProductsParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListFeaturedProducts(ctx context.Context, arg *ListFeaturedProductsParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.listFeaturedProductsStmt, ListFeaturedProducts, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProducts = `-- name: ListProducts :many
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products
WHERE store_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg *ListProductsParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.listProductsStmt, ListProducts, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProductsByStatus = `-- name: ListProductsByStatus :many
SELECT id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at FROM products
WHERE store_id = $1 AND status = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListProductsByStatusParams struct {
	StoreID uuid.UUID     `db:"store_id" json:"store_id"`
	Status  ProductStatus `db:"status" json:"status"`
	Limit   int32         `db:"limit" json:"limit"`
	Offset  int32         `db:"offset" json:"offset"`
}

func (q *Queries) ListProductsByStatus(ctx context.Context, arg *ListProductsByStatusParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.listProductsByStatusStmt, ListProductsByStatus,
		arg.StoreID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    type = COALESCE($5, type),
    status = COALESCE($6, status),
    price = COALESCE($7, price),
    compare_at_price = COALESCE($8, compare_at_price),
    cost_price = COALESCE($9, cost_price),
    sku = COALESCE($10, sku),
    barcode = COALESCE($11, barcode),
    weight = COALESCE($12, weight),
    weight_unit = COALESCE($13, weight_unit),
    is_taxable = COALESCE($14, is_taxable),
    is_featured = COALESCE($15, is_featured),
    is_gift_card = COALESCE($16, is_gift_card),
    requires_shipping = COALESCE($17, requires_shipping),
    inventory_quantity = COALESCE($18, inventory_quantity),
    inventory_policy = COALESCE($19, inventory_policy),
    inventory_tracking = COALESCE($20, inventory_tracking),
    seo_title = COALESCE($21, seo_title),
    seo_description = COALESCE($22, seo_description),
    metadata = COALESCE($23, metadata)
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID                uuid.UUID             `db:"id" json:"id"`
	Name              string                `db:"name" json:"name"`
	Slug              string                `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	Type        ProductType    `db:"type" json:"type"`
	Status      ProductStatus  `db:"status" json:"status"`
	Price       string         `db:"price" json:"price"`
	CompareAtPrice    sql.NullString        `db:"compare_at_price" json:"compare_at_price"`
	CostPrice         sql.NullString        `db:"cost_price" json:"cost_price"`
	Sku               sql.NullString        `db:"sku" json:"sku"`
	Barcode           sql.NullString        `db:"barcode" json:"barcode"`
	Weight            sql.NullString        `db:"weight" json:"weight"`
	WeightUnit        sql.NullString        `db:"weight_unit" json:"weight_unit"`
	IsTaxable         sql.NullBool          `db:"is_taxable" json:"is_taxable"`
	IsFeatured        sql.NullBool          `db:"is_featured" json:"is_featured"`
	IsGiftCard        sql.NullBool          `db:"is_gift_card" json:"is_gift_card"`
	RequiresShipping  sql.NullBool          `db:"requires_shipping" json:"requires_shipping"`
	InventoryQuantity sql.NullInt32         `db:"inventory_quantity" json:"inventory_quantity"`
	InventoryPolicy   sql.NullString        `db:"inventory_policy" json:"inventory_policy"`
	InventoryTracking sql.NullBool          `db:"inventory_tracking" json:"inventory_tracking"`
	SeoTitle          sql.NullString        `db:"seo_title" json:"seo_title"`
	SeoDescription    sql.NullString        `db:"seo_description" json:"seo_description"`
	Metadata          pqtype.NullRawMessage `db:"metadata" json:"metadata"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg *UpdateProductParams) (*Product, error) {
	row := q.queryRow(ctx, q.updateProductStmt, UpdateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Type,
		arg.Status,
		arg.Price,
		arg.CompareAtPrice,
		arg.CostPrice,
		arg.Sku,
		arg.Barcode,
		arg.Weight,
		arg.WeightUnit,
		arg.IsTaxable,
		arg.IsFeatured,
		arg.IsGiftCard,
		arg.RequiresShipping,
		arg.InventoryQuantity,
		arg.InventoryPolicy,
		arg.InventoryTracking,
		arg.SeoTitle,
		arg.SeoDescription,
		arg.Metadata,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const UpdateProductInventory = `-- name: UpdateProductInventory :one
UPDATE products
SET
    inventory_quantity = inventory_quantity + $2
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, store_id, name, slug, description, type, status, price, compare_at_price, cost_price, sku, barcode, weight, weight_unit, is_taxable, is_featured, is_gift_card, requires_shipping, inventory_quantity, inventory_policy, inventory_tracking, seo_title, seo_description, metadata, created_at, updated_at, deleted_at
`

type UpdateProductInventoryParams struct {
	ID                uuid.UUID     `db:"id" json:"id"`
	InventoryQuantity sql.NullInt32 `db:"inventory_quantity" json:"inventory_quantity"`
}

func (q *Queries) UpdateProductInventory(ctx context.Context, arg *UpdateProductInventoryParams) (*Product, error) {
	row := q.queryRow(ctx, q.updateProductInventoryStmt, UpdateProductInventory, arg.ID, arg.InventoryQuantity)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Type,
		&i.Status,
		&i.Price,
		&i.CompareAtPrice,
		&i.CostPrice,
		&i.Sku,
		&i.Barcode,
		&i.Weight,
		&i.WeightUnit,
		&i.IsTaxable,
		&i.IsFeatured,
		&i.IsGiftCard,
		&i.RequiresShipping,
		&i.InventoryQuantity,
		&i.InventoryPolicy,
		&i.InventoryTracking,
		&i.SeoTitle,
		&i.SeoDescription,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
