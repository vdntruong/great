// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: product_category.sql

package dao

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const AddProductCategory = `-- name: AddProductCategory :exec
INSERT INTO product_categories (product_id, category_id)
VALUES ($1, $2)
`

type AddProductCategoryParams struct {
	ProductID  uuid.UUID `db:"product_id" json:"product_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) AddProductCategory(ctx context.Context, arg *AddProductCategoryParams) error {
	_, err := q.exec(ctx, q.addProductCategoryStmt, AddProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const CountCategoryProducts = `-- name: CountCategoryProducts :one
SELECT COUNT(*) FROM products p
JOIN product_categories pc ON p.id = pc.product_id
WHERE pc.category_id = $1 AND p.deleted_at IS NULL
`

func (q *Queries) CountCategoryProducts(ctx context.Context, categoryID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countCategoryProductsStmt, CountCategoryProducts, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetCategoryProducts = `-- name: GetCategoryProducts :many
SELECT p.id, p.store_id, p.name, p.slug, p.description, p.type, p.status, p.price, p.compare_at_price, p.cost_price, p.sku, p.barcode, p.weight, p.weight_unit, p.is_taxable, p.is_featured, p.is_gift_card, p.requires_shipping, p.inventory_quantity, p.inventory_policy, p.inventory_tracking, p.seo_title, p.seo_description, p.metadata, p.created_at, p.updated_at, p.deleted_at FROM products p
JOIN product_categories pc ON p.id = pc.product_id
WHERE pc.category_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetCategoryProductsParams struct {
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetCategoryProducts(ctx context.Context, arg *GetCategoryProductsParams) ([]*Product, error) {
	rows, err := q.query(ctx, q.getCategoryProductsStmt, GetCategoryProducts, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductCategories = `-- name: GetProductCategories :many
SELECT c.id, c.store_id, c.name, c.slug, c.description, c.parent_id, c.sort_order, c.created_at, c.updated_at FROM store_categories c
JOIN product_categories pc ON c.id = pc.category_id
WHERE pc.product_id = $1
`

func (q *Queries) GetProductCategories(ctx context.Context, productID uuid.UUID) ([]*StoreCategory, error) {
	rows, err := q.query(ctx, q.getProductCategoriesStmt, GetProductCategories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*StoreCategory{}
	for rows.Next() {
		var i StoreCategory
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveAllProductCategories = `-- name: RemoveAllProductCategories :exec
DELETE FROM product_categories
WHERE product_id = $1
`

func (q *Queries) RemoveAllProductCategories(ctx context.Context, productID uuid.UUID) error {
	_, err := q.exec(ctx, q.removeAllProductCategoriesStmt, RemoveAllProductCategories, productID)
	return err
}

const RemoveProductCategory = `-- name: RemoveProductCategory :exec
DELETE FROM product_categories
WHERE product_id = $1 AND category_id = $2
`

type RemoveProductCategoryParams struct {
	ProductID  uuid.UUID `db:"product_id" json:"product_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) RemoveProductCategory(ctx context.Context, arg *RemoveProductCategoryParams) error {
	_, err := q.exec(ctx, q.removeProductCategoryStmt, RemoveProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const UpdateProductCategories = `-- name: UpdateProductCategories :exec
WITH new_categories AS (
    SELECT unnest($2::uuid[]) AS category_id
)
DELETE FROM product_categories pc
WHERE pc.product_id = $1
    AND pc.category_id NOT IN (SELECT category_id FROM new_categories)
`

type UpdateProductCategoriesParams struct {
	ProductID uuid.UUID   `db:"product_id" json:"product_id"`
	Column2   []uuid.UUID `db:"column_2" json:"column_2"`
}

func (q *Queries) UpdateProductCategories(ctx context.Context, arg *UpdateProductCategoriesParams) error {
	_, err := q.exec(ctx, q.updateProductCategoriesStmt, UpdateProductCategories, arg.ProductID, pq.Array(arg.Column2))
	return err
}
