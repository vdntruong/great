// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: store.sql

package dao

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const CountStores = `-- name: CountStores :one
SELECT COUNT(*) FROM stores
WHERE deleted_at IS NULL
`

func (q *Queries) CountStores(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countStoresStmt, CountStores)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountStoresByOwner = `-- name: CountStoresByOwner :one
SELECT COUNT(*) FROM stores
WHERE owner_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountStoresByOwner(ctx context.Context, ownerID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countStoresByOwnerStmt, CountStoresByOwner, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateStore = `-- name: CreateStore :one
INSERT INTO stores (
    name,
    slug,
    description,
    logo_url,
    cover_url,
    status,
    is_verified,
    owner_id,
    contact_email,
    contact_phone,
    address,
    settings
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at
`

type CreateStoreParams struct {
	Name         string                `db:"name" json:"name"`
	Slug         string                `db:"slug" json:"slug"`
	Description  sql.NullString        `db:"description" json:"description"`
	LogoUrl      sql.NullString        `db:"logo_url" json:"logo_url"`
	CoverUrl   sql.NullString `db:"cover_url" json:"cover_url"`
	Status     StoreStatus    `db:"status" json:"status"`
	IsVerified bool           `db:"is_verified" json:"is_verified"`
	OwnerID      uuid.UUID             `db:"owner_id" json:"owner_id"`
	ContactEmail sql.NullString        `db:"contact_email" json:"contact_email"`
	ContactPhone sql.NullString        `db:"contact_phone" json:"contact_phone"`
	Address      sql.NullString        `db:"address" json:"address"`
	Settings     pqtype.NullRawMessage `db:"settings" json:"settings"`
}

func (q *Queries) CreateStore(ctx context.Context, arg *CreateStoreParams) (*Store, error) {
	row := q.queryRow(ctx, q.createStoreStmt, CreateStore,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.LogoUrl,
		arg.CoverUrl,
		arg.Status,
		arg.IsVerified,
		arg.OwnerID,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.Address,
		arg.Settings,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const DeleteStore = `-- name: DeleteStore :exec
UPDATE stores
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteStore(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteStoreStmt, DeleteStore, id)
	return err
}

const GetStore = `-- name: GetStore :one
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStore(ctx context.Context, id uuid.UUID) (*Store, error) {
	row := q.queryRow(ctx, q.getStoreStmt, GetStore, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const GetStoreBySlug = `-- name: GetStoreBySlug :one
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores
WHERE slug = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStoreBySlug(ctx context.Context, slug string) (*Store, error) {
	row := q.queryRow(ctx, q.getStoreBySlugStmt, GetStoreBySlug, slug)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const ListStores = `-- name: ListStores :many
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListStoresParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListStores(ctx context.Context, arg *ListStoresParams) ([]*Store, error) {
	rows, err := q.query(ctx, q.listStoresStmt, ListStores, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.LogoUrl,
			&i.CoverUrl,
			&i.Status,
			&i.IsVerified,
			&i.OwnerID,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListStoresByOwner = `-- name: ListStoresByOwner :many
SELECT id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at FROM stores
WHERE owner_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListStoresByOwnerParams struct {
	OwnerID uuid.UUID `db:"owner_id" json:"owner_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListStoresByOwner(ctx context.Context, arg *ListStoresByOwnerParams) ([]*Store, error) {
	rows, err := q.query(ctx, q.listStoresByOwnerStmt, ListStoresByOwner, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Store{}
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.LogoUrl,
			&i.CoverUrl,
			&i.Status,
			&i.IsVerified,
			&i.OwnerID,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.Address,
			&i.Settings,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateStore = `-- name: UpdateStore :one
UPDATE stores
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    logo_url = COALESCE($5, logo_url),
    cover_url = COALESCE($6, cover_url),
    status = COALESCE($7, status),
    is_verified = COALESCE($8, is_verified),
    contact_email = COALESCE($9, contact_email),
    contact_phone = COALESCE($10, contact_phone),
    address = COALESCE($11, address),
    settings = COALESCE($12, settings)
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, slug, description, logo_url, cover_url, status, is_verified, owner_id, contact_email, contact_phone, address, settings, created_at, updated_at, deleted_at
`

type UpdateStoreParams struct {
	ID           uuid.UUID             `db:"id" json:"id"`
	Name         string                `db:"name" json:"name"`
	Slug         string                `db:"slug" json:"slug"`
	Description  sql.NullString        `db:"description" json:"description"`
	LogoUrl      sql.NullString        `db:"logo_url" json:"logo_url"`
	CoverUrl   sql.NullString `db:"cover_url" json:"cover_url"`
	Status     StoreStatus    `db:"status" json:"status"`
	IsVerified bool           `db:"is_verified" json:"is_verified"`
	ContactEmail sql.NullString        `db:"contact_email" json:"contact_email"`
	ContactPhone sql.NullString        `db:"contact_phone" json:"contact_phone"`
	Address      sql.NullString        `db:"address" json:"address"`
	Settings     pqtype.NullRawMessage `db:"settings" json:"settings"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg *UpdateStoreParams) (*Store, error) {
	row := q.queryRow(ctx, q.updateStoreStmt, UpdateStore,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.LogoUrl,
		arg.CoverUrl,
		arg.Status,
		arg.IsVerified,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.Address,
		arg.Settings,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.LogoUrl,
		&i.CoverUrl,
		&i.Status,
		&i.IsVerified,
		&i.OwnerID,
		&i.ContactEmail,
		&i.ContactPhone,
		&i.Address,
		&i.Settings,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
