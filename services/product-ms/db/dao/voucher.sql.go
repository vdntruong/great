// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: voucher.sql

package dao

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const AddVoucherCategory = `-- name: HandleAddVoucherCategory :exec
INSERT INTO voucher_categories (voucher_id, category_id)
VALUES ($1, $2)
`

type AddVoucherCategoryParams struct {
	VoucherID  uuid.UUID `db:"voucher_id" json:"voucher_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) AddVoucherCategory(ctx context.Context, arg *AddVoucherCategoryParams) error {
	_, err := q.exec(ctx, q.addVoucherCategoryStmt, AddVoucherCategory, arg.VoucherID, arg.CategoryID)
	return err
}

const AddVoucherProduct = `-- name: HandleAddVoucherProduct :exec
INSERT INTO voucher_products (voucher_id, product_id)
VALUES ($1, $2)
`

type AddVoucherProductParams struct {
	VoucherID uuid.UUID `db:"voucher_id" json:"voucher_id"`
	ProductID uuid.UUID `db:"product_id" json:"product_id"`
}

func (q *Queries) AddVoucherProduct(ctx context.Context, arg *AddVoucherProductParams) error {
	_, err := q.exec(ctx, q.addVoucherProductStmt, AddVoucherProduct, arg.VoucherID, arg.ProductID)
	return err
}

const CountActiveVouchers = `-- name: CountActiveVouchers :one
SELECT COUNT(*) FROM vouchers
WHERE store_id = $1
    AND status = 'active'
    AND (end_date IS NULL OR end_date > CURRENT_TIMESTAMP)
`

func (q *Queries) CountActiveVouchers(ctx context.Context, storeID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countActiveVouchersStmt, CountActiveVouchers, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountVouchers = `-- name: CountVouchers :one
SELECT COUNT(*) FROM vouchers
WHERE store_id = $1
`

func (q *Queries) CountVouchers(ctx context.Context, storeID uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.countVouchersStmt, CountVouchers, storeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateVoucher = `-- name: HandleCreate :one
INSERT INTO vouchers (
    store_id,
    code,
    type,
    value,
    min_purchase_amount,
    max_discount_amount,
    start_date,
    end_date,
    usage_limit,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at
`

type CreateVoucherParams struct {
	StoreID           uuid.UUID      `db:"store_id" json:"store_id"`
	Code       string         `db:"code" json:"code"`
	Type       VoucherType    `db:"type" json:"type"`
	Value      sql.NullString `db:"value" json:"value"`
	MinPurchaseAmount sql.NullString `db:"min_purchase_amount" json:"min_purchase_amount"`
	MaxDiscountAmount sql.NullString `db:"max_discount_amount" json:"max_discount_amount"`
	StartDate         time.Time      `db:"start_date" json:"start_date"`
	EndDate           sql.NullTime   `db:"end_date" json:"end_date"`
	UsageLimit sql.NullInt32  `db:"usage_limit" json:"usage_limit"`
	Status     VoucherStatus  `db:"status" json:"status"`
}

func (q *Queries) CreateVoucher(ctx context.Context, arg *CreateVoucherParams) (*Voucher, error) {
	row := q.queryRow(ctx, q.createVoucherStmt, CreateVoucher,
		arg.StoreID,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinPurchaseAmount,
		arg.MaxDiscountAmount,
		arg.StartDate,
		arg.EndDate,
		arg.UsageLimit,
		arg.Status,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.UsageCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteVoucher = `-- name: HandleDelete :exec
DELETE FROM vouchers
WHERE id = $1
`

func (q *Queries) DeleteVoucher(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteVoucherStmt, DeleteVoucher, id)
	return err
}

const GetVoucher = `-- name: HandleGet :one
SELECT id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at FROM vouchers
WHERE id = $1
`

func (q *Queries) GetVoucher(ctx context.Context, id uuid.UUID) (*Voucher, error) {
	row := q.queryRow(ctx, q.getVoucherStmt, GetVoucher, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.UsageCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVoucherByCode = `-- name: GetVoucherByCode :one
SELECT id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at FROM vouchers
WHERE store_id = $1 AND code = $2
`

type GetVoucherByCodeParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Code    string    `db:"code" json:"code"`
}

func (q *Queries) GetVoucherByCode(ctx context.Context, arg *GetVoucherByCodeParams) (*Voucher, error) {
	row := q.queryRow(ctx, q.getVoucherByCodeStmt, GetVoucherByCode, arg.StoreID, arg.Code)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.UsageCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetVoucherCategories = `-- name: GetVoucherCategories :many
SELECT c.id, c.store_id, c.name, c.slug, c.description, c.parent_id, c.sort_order, c.created_at, c.updated_at FROM store_categories c
JOIN voucher_categories vc ON c.id = vc.category_id
WHERE vc.voucher_id = $1
`

func (q *Queries) GetVoucherCategories(ctx context.Context, voucherID uuid.UUID) ([]*StoreCategory, error) {
	rows, err := q.query(ctx, q.getVoucherCategoriesStmt, GetVoucherCategories, voucherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*StoreCategory{}
	for rows.Next() {
		var i StoreCategory
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetVoucherProducts = `-- name: GetVoucherProducts :many
SELECT p.id, p.store_id, p.name, p.slug, p.description, p.type, p.status, p.price, p.compare_at_price, p.cost_price, p.sku, p.barcode, p.weight, p.weight_unit, p.is_taxable, p.is_featured, p.is_gift_card, p.requires_shipping, p.inventory_quantity, p.inventory_policy, p.inventory_tracking, p.seo_title, p.seo_description, p.metadata, p.created_at, p.updated_at, p.deleted_at FROM products p
JOIN voucher_products vp ON p.id = vp.product_id
WHERE vp.voucher_id = $1
`

func (q *Queries) GetVoucherProducts(ctx context.Context, voucherID uuid.UUID) ([]*Product, error) {
	rows, err := q.query(ctx, q.getVoucherProductsStmt, GetVoucherProducts, voucherID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Type,
			&i.Status,
			&i.Price,
			&i.CompareAtPrice,
			&i.CostPrice,
			&i.Sku,
			&i.Barcode,
			&i.Weight,
			&i.WeightUnit,
			&i.IsTaxable,
			&i.IsFeatured,
			&i.IsGiftCard,
			&i.RequiresShipping,
			&i.InventoryQuantity,
			&i.InventoryPolicy,
			&i.InventoryTracking,
			&i.SeoTitle,
			&i.SeoDescription,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const IncrementVoucherUsage = `-- name: IncrementVoucherUsage :one
UPDATE vouchers
SET usage_count = usage_count + 1
WHERE id = $1 AND (usage_limit IS NULL OR usage_count < usage_limit)
RETURNING id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at
`

func (q *Queries) IncrementVoucherUsage(ctx context.Context, id uuid.UUID) (*Voucher, error) {
	row := q.queryRow(ctx, q.incrementVoucherUsageStmt, IncrementVoucherUsage, id)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.UsageCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListActiveVouchers = `-- name: ListActiveVouchers :many
SELECT id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at FROM vouchers
WHERE store_id = $1
    AND status = 'active'
    AND (end_date IS NULL OR end_date > CURRENT_TIMESTAMP)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActiveVouchersParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListActiveVouchers(ctx context.Context, arg *ListActiveVouchersParams) ([]*Voucher, error) {
	rows, err := q.query(ctx, q.listActiveVouchersStmt, ListActiveVouchers, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Type,
			&i.Value,
			&i.MinPurchaseAmount,
			&i.MaxDiscountAmount,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.UsageCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListVouchers = `-- name: HandleList :many
SELECT id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at FROM vouchers
WHERE store_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListVouchersParams struct {
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
	Limit   int32     `db:"limit" json:"limit"`
	Offset  int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListVouchers(ctx context.Context, arg *ListVouchersParams) ([]*Voucher, error) {
	rows, err := q.query(ctx, q.listVouchersStmt, ListVouchers, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Voucher{}
	for rows.Next() {
		var i Voucher
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Code,
			&i.Type,
			&i.Value,
			&i.MinPurchaseAmount,
			&i.MaxDiscountAmount,
			&i.StartDate,
			&i.EndDate,
			&i.UsageLimit,
			&i.UsageCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveVoucherCategory = `-- name: HandleRemoveVoucherCategory :exec
DELETE FROM voucher_categories
WHERE voucher_id = $1 AND category_id = $2
`

type RemoveVoucherCategoryParams struct {
	VoucherID  uuid.UUID `db:"voucher_id" json:"voucher_id"`
	CategoryID uuid.UUID `db:"category_id" json:"category_id"`
}

func (q *Queries) RemoveVoucherCategory(ctx context.Context, arg *RemoveVoucherCategoryParams) error {
	_, err := q.exec(ctx, q.removeVoucherCategoryStmt, RemoveVoucherCategory, arg.VoucherID, arg.CategoryID)
	return err
}

const RemoveVoucherProduct = `-- name: HandleRemoveVoucherProduct :exec
DELETE FROM voucher_products
WHERE voucher_id = $1 AND product_id = $2
`

type RemoveVoucherProductParams struct {
	VoucherID uuid.UUID `db:"voucher_id" json:"voucher_id"`
	ProductID uuid.UUID `db:"product_id" json:"product_id"`
}

func (q *Queries) RemoveVoucherProduct(ctx context.Context, arg *RemoveVoucherProductParams) error {
	_, err := q.exec(ctx, q.removeVoucherProductStmt, RemoveVoucherProduct, arg.VoucherID, arg.ProductID)
	return err
}

const UpdateVoucher = `-- name: HandleUpdate :one
UPDATE vouchers
SET
    code = COALESCE($2, code),
    type = COALESCE($3, type),
    value = COALESCE($4, value),
    min_purchase_amount = COALESCE($5, min_purchase_amount),
    max_discount_amount = COALESCE($6, max_discount_amount),
    start_date = COALESCE($7, start_date),
    end_date = COALESCE($8, end_date),
    usage_limit = COALESCE($9, usage_limit),
    status = COALESCE($10, status)
WHERE id = $1
RETURNING id, store_id, code, type, value, min_purchase_amount, max_discount_amount, start_date, end_date, usage_limit, usage_count, status, created_at, updated_at
`

type UpdateVoucherParams struct {
	ID                uuid.UUID      `db:"id" json:"id"`
	Code       string         `db:"code" json:"code"`
	Type       VoucherType    `db:"type" json:"type"`
	Value      sql.NullString `db:"value" json:"value"`
	MinPurchaseAmount sql.NullString `db:"min_purchase_amount" json:"min_purchase_amount"`
	MaxDiscountAmount sql.NullString `db:"max_discount_amount" json:"max_discount_amount"`
	StartDate         time.Time      `db:"start_date" json:"start_date"`
	EndDate           sql.NullTime   `db:"end_date" json:"end_date"`
	UsageLimit sql.NullInt32  `db:"usage_limit" json:"usage_limit"`
	Status     VoucherStatus  `db:"status" json:"status"`
}

func (q *Queries) UpdateVoucher(ctx context.Context, arg *UpdateVoucherParams) (*Voucher, error) {
	row := q.queryRow(ctx, q.updateVoucherStmt, UpdateVoucher,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinPurchaseAmount,
		arg.MaxDiscountAmount,
		arg.StartDate,
		arg.EndDate,
		arg.UsageLimit,
		arg.Status,
	)
	var i Voucher
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinPurchaseAmount,
		&i.MaxDiscountAmount,
		&i.StartDate,
		&i.EndDate,
		&i.UsageLimit,
		&i.UsageCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
